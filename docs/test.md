<!----- Conversion time: 41.93 seconds.


Using this Markdown file:

1. Cut and paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* GD2md-html version 1.0β13
* Fri Jan 11 2019 01:29:08 GMT-0800 (PST)
* Source doc: https://docs.google.com/open?id=17FRgryar_1vLelIXgcs_X--a-LuxQQktFAP-NGrquk4

WARNING:
Inline drawings not supported: look for ">>>>>  gd2md-html alert:  inline drawings..." in output.

* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server.

WARNING:
You have 13 H1 headings. You may want to use the "H1 -> H2" option to demote all headings by one level.

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 2; ALERTS: 92.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>
<a href="#gdcalert17">alert17</a>
<a href="#gdcalert18">alert18</a>
<a href="#gdcalert19">alert19</a>
<a href="#gdcalert20">alert20</a>
<a href="#gdcalert21">alert21</a>
<a href="#gdcalert22">alert22</a>
<a href="#gdcalert23">alert23</a>
<a href="#gdcalert24">alert24</a>
<a href="#gdcalert25">alert25</a>
<a href="#gdcalert26">alert26</a>
<a href="#gdcalert27">alert27</a>
<a href="#gdcalert28">alert28</a>
<a href="#gdcalert29">alert29</a>
<a href="#gdcalert30">alert30</a>
<a href="#gdcalert31">alert31</a>
<a href="#gdcalert32">alert32</a>
<a href="#gdcalert33">alert33</a>
<a href="#gdcalert34">alert34</a>
<a href="#gdcalert35">alert35</a>
<a href="#gdcalert36">alert36</a>
<a href="#gdcalert37">alert37</a>
<a href="#gdcalert38">alert38</a>
<a href="#gdcalert39">alert39</a>
<a href="#gdcalert40">alert40</a>
<a href="#gdcalert41">alert41</a>
<a href="#gdcalert42">alert42</a>
<a href="#gdcalert43">alert43</a>
<a href="#gdcalert44">alert44</a>
<a href="#gdcalert45">alert45</a>
<a href="#gdcalert46">alert46</a>
<a href="#gdcalert47">alert47</a>
<a href="#gdcalert48">alert48</a>
<a href="#gdcalert49">alert49</a>
<a href="#gdcalert50">alert50</a>
<a href="#gdcalert51">alert51</a>
<a href="#gdcalert52">alert52</a>
<a href="#gdcalert53">alert53</a>
<a href="#gdcalert54">alert54</a>
<a href="#gdcalert55">alert55</a>
<a href="#gdcalert56">alert56</a>
<a href="#gdcalert57">alert57</a>
<a href="#gdcalert58">alert58</a>
<a href="#gdcalert59">alert59</a>
<a href="#gdcalert60">alert60</a>
<a href="#gdcalert61">alert61</a>
<a href="#gdcalert62">alert62</a>
<a href="#gdcalert63">alert63</a>
<a href="#gdcalert64">alert64</a>
<a href="#gdcalert65">alert65</a>
<a href="#gdcalert66">alert66</a>
<a href="#gdcalert67">alert67</a>
<a href="#gdcalert68">alert68</a>
<a href="#gdcalert69">alert69</a>
<a href="#gdcalert70">alert70</a>
<a href="#gdcalert71">alert71</a>
<a href="#gdcalert72">alert72</a>
<a href="#gdcalert73">alert73</a>
<a href="#gdcalert74">alert74</a>
<a href="#gdcalert75">alert75</a>
<a href="#gdcalert76">alert76</a>
<a href="#gdcalert77">alert77</a>
<a href="#gdcalert78">alert78</a>
<a href="#gdcalert79">alert79</a>
<a href="#gdcalert80">alert80</a>
<a href="#gdcalert81">alert81</a>
<a href="#gdcalert82">alert82</a>
<a href="#gdcalert83">alert83</a>
<a href="#gdcalert84">alert84</a>
<a href="#gdcalert85">alert85</a>
<a href="#gdcalert86">alert86</a>
<a href="#gdcalert87">alert87</a>
<a href="#gdcalert88">alert88</a>
<a href="#gdcalert89">alert89</a>
<a href="#gdcalert90">alert90</a>
<a href="#gdcalert91">alert91</a>
<a href="#gdcalert92">alert92</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>



# Tutorial - Let's make a Bouncy Fant Game!

Einleitung 

Hallo und herzlich willkommen beim learn to proGrAME-Tutorial.  

Hier lernst du, wie du dein erstes 2D-Spiel mit der Unity Engine entwickelst. Damit du einen einfachen und problemlosen Einstieg in das Thema hast werden wir das Spiel "BouncyFant" selber versuchen nach zu programmieren.  

 

**Warum verwenden wir die Unity Engine?** 

Wir verwenden die Unity Engine, weil sie viele Features von Haus aus eingebaut hat die wir für die Erstellung eines Spiels brauchen. Somit können wir uns mehr auf das Design von unserem Spiel und die grundlegende Programmierung konzentrieren. Unity hat zum Beispiel bereits eine richtig coole Physik Engine eingebaut hat mit der wir lustige Effekte in unserem Spiel erschaffen können. 

 

Die Unity Engine wird auch von _professionellen Spielentwicklern_ verwendet. So wurden zum Beispiel das Online Kartenspiel „_Hearthstone_" von Blizzard, oder das beliebte Handygame „_Temple Run_" mit Unity erstellt.  

 

Über das Tutorial 

In diesem Tutorial wirst du dich mit Unity und einigen Abschnitten Programmcode vertraut machen. Nach dem Absolvieren des Tutorials wird dir mehr Freiraum gegeben, eigenständig zu entwickeln.

Wenn du dir nicht sicher bist, ob du ein Wort richtig verstehst, schau bitte zuerst im Glossar selbst nach. Unsere Videos auf dem Youtube Kanal helfen dir bei schwierigen Abschnitten. Sollte etwas schief laufen, kannst du natürlich nachfragen. Für Notfälle ist nach jedem Kapitel auch ein Link zu einer Projekt-Datei mit dem jeweiligen Fortschritt vorhanden. 


## Grundlegende Infos

Zum Programmieren benötigt man Entwicklungswerkzeuge, wie einen [Compiler](https://de.wikipedia.org/wiki/Compiler), einen [Assembler](https://de.wikipedia.org/wiki/Assembler_(Informatik)) oder einen [Interpreter](https://de.wikipedia.org/wiki/Interpreter). Wichtig ist ein Editor, mit dem man den Quellcode schreibt (z.B. Notepad++, TextWrangler, Sublime, Geany, ...). Diese Entwicklungswerkzeuge können getrennt voneinander oder in einem Gesamtpaket eingesetzt werden. Wird ein Gesamtpaket verwendet, spricht man von einer integrierten Entwicklungsumgebung (auf Englisch: "Integrated Development Environment"  oder kurz: IDE). 

Wir verwenden in diesem Tutorial [Unity 5.6.2](https://unity3d.com/de/get-unity/download/archive). Genaugenommen sind das sogar zwei IDEs, die zu einem Paket zusammengeschnürt wurden: Die Unity-IDE und Visual Studio Community Edition. Für dieses Tutorial solltet ihr daher Unity und Visual Studio installiert haben. Wir verwenden die englische Version (für die gibt es im www auch mehr Tutorials).

<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant0.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant0.png "image_tooltip")


Abbildung: Unity IDE mit einem Snake-Spiel



<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant1.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant1.png "image_tooltip")


Abbildung: Microsoft Visual Studio Community Edition 


## Das Spiel


#### Die Hintergrundstory


##### Bouncy Fant - Der Anfang

Der verrückte Dr. Clamberwoods hat ein Netzwerk aus Maschinen entworfen, mit dem er die Gesetze der Physik kontrollieren und verändern kann. Diese Maschinen konnte er jedoch nur an einem Ort installieren, an dem sie unentdeckt blieben und der von anderen Menschen weit, weit entfernt war. Jener Ort war ein unbekanntes Stück Regenwald in Zentralafrika und die Heimat der höchst seltenen, aber intelligenten Miniatur-Elefanten,  die sich selbst wegen ihres elastischen Körperbaus und ihrer Fähigkeit sehr hoch springen zu können Bouncy Fants nennen.

Dr. Clamberwoods finsterer Plan ist es, mit Hilfe seiner Maschinen sämtliche Bäume zu entwurzeln und dem Waldboden seine Bodenschätze zu entreißen. Nur mit den Diamanten und Edelmetallen, die er aus dem Regenwaldboden mit seinen Maschinen extrahiert, kann er die enormen Ressourcen aufbringen, um ein noch mächtigeres Geflecht aus Maschinen zu bauen, das letztendlich die physikalischen Gesetze auf dem ganzen Planeten durcheinander bringen und ihm zur Herrschaft über die Welt verhelfen soll. 

Die Tiere des Waldes sind verzweifelt und befürchten, dass sie alle sterben müssen. Doch zwei junge Bouncy Fants wollen die Hoffnung nicht aufgeben.Die Elefanten Elli und Ossi machen sich auf den Weg, um Dr. Clamberwoods zu stoppen und den Regenwald und die ganze Welt zu retten.

Die zwei Elefanten müssen auf ihren Abenteuern magische Gegenstände finden,hilfsbereite Tiere befragen und Teile des tödlichen Geflechts von Dr. Clamberwoods Maschinen zerstören.


#### Das Spielprinzip

Im Spiel geht es geht darum, einen Elefanten möglichst schnell durch eine Welt, in der übertriebene und unglaubliche physikalische Gesetze gelten, zu steuern. Während unterschiedliche Gegenstände von oben auf die Bouncy Fants herabprasseln, müsst ihr versuchen einen seltenen Gegenstand (z.B. einen magischen Pilz) zu erreichen. Wer zuerst den magischen Pilz erreicht, hat gewonnen. 



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant2.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant2.png "image_tooltip")


Abbildung: Unser Spiel: Bouncy Fant 


# Teil 1 - Neues Projekt erstellen und Assets einfügen

Wenn du Unity startest, erscheint zuerst ein Startfenster. Klicke dort auf _"NEW"_.



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant3.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant3.png "image_tooltip")


Gib bei den erweiterten Einstellungen einen sinnvollen Namen (z.B. <DeinName>_BouncyFant) ein. Ganz wichtig ist es, beim Projekttyp_ "2D"_ auszuwählen. 



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant4.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant4.png "image_tooltip")


Bei Location kannst du den Ordnerpfad auswählen wo du dein Projekt, also dein Spiel, abspeichern möchtest. Am besten du speicherst das Projekt in deinem privaten Ordner ab. 

 

**Achtung!**  

Es kann sein, dass an deiner Schule Netzwerklaufwerke verwendet werden und du dein Projekt unter einem bestimmten Laufwerk (bzw. Pfad) abspeichern musst. Frag am besten deine Lehrperson. 

 

Sobald du Pfad, Name und „2D" ausgewählt hast, kannst du bereits auf "_Create project"_ klicken. 


## Arbeitsbereich kennenlernen und konfigurieren


### Listenansicht im Assetsbereich

In diesem Tutorial sehen wir auf den Screenshots im Assetsbereich die Listenansicht. Wenn man diese Ansicht in Unity anpassen möchte, kann man dies einfach im Assetsbereich rechts unten tun (siehe Screenshot) oder man bewegt die Maustaste über den Bereich der Assets und hält die die Taste STRG gedrückt, während man am Mausrad dreht.



<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant5.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant5.png "image_tooltip")



## Neue Ordner und Assets hinzufügen

Bevor wir in Unity unsere Ordnerstruktur anlegen, laden wir uns einmal ein paar Assets aus dem Web herunter und speichern diese in den entsprechenden Objektordner. Die Assets, mit denen wir arbeiten werden, finden wir an folgenden Orten:



*   [www.comber.at/dev/assets.zip](www.comber.at/dev/assets.zip)
*   [https://www.gameart2d.com/free-platformer-game-tileset.html](https://www.gameart2d.com/free-platformer-game-tileset.html) 

In Unity fügen wir zuerst neue Ordner hinzu. Für Dein Projekt brauchst Du folgende Ordner: 



*   Material (für die Materialeigenschaften für die Physiksimulation)
*   Scripts (für die zu programmierenden Scripte)
*   Sprites (für die Grafiken)
*   Vorlagen (für Spielobjekte, die wir als Vorlagen erstellen und verwenden)

Neue Ordner, aber auch Sprites, Scripts, Materials und vieles mehr, legt man mittels Rechtsklick in den "Assets"-Bereich und dann durch einen Klick auf _Create/Folder_ an.

 



<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant6.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant6.png "image_tooltip")


Um die Spielegrafik in Unity zu importieren klicken wir doppelt in den soeben erstellten Ordner Sprites und dort auf "Import New Asset".



<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant7.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant7.png "image_tooltip")


Im nachfolgenden Fenster navigieren wir zu dem Ordner, in dem wir unsere heruntergeladenen Spielegrafiken gespeichert haben, wählen Elefant und klicken auf _Import. _(Mehr zum Erstellen von Spielegrafiken findest du in unserem GIMP-Tutorial auf Moodle oder auf unserem Youtube-Channel: [learn to proGrAME](https://youtu.be/C1rcqXZEk7M)).



<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant8.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant8.png "image_tooltip")



## Das Sprite zerschneiden 

Im Folgenden möchten wir nun die einzelnen Animationsstufen des Elefanten aus dem Spritesheet extrahieren. Man kann sich das so vorstellen, als ob man das Spritesheet einfach zerschneiden würde. Wenn wir nämlich den Elefanten gleich in unserem Spiel einsetzen würden, dann hätten wir ja in Wirklichkeit ein Bild mit drei Elefanten im Spiel. Bevor wir jedoch mit dem Zerschneiden des Spritesheets anfangen können, müssen wir noch den _Sprite Mode _von_ Single_ auf _Multiple_ ändern. Damit teilen wir Unity mit, dass in unserem importierten Bild mehrere Animationsstufen eines Sprites vorhanden sind. 

Das Zerschneiden bewerkstelligen wir, indem wir den _Sprite Editor_ öffnen.  



<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant9.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant9.png "image_tooltip")


Falls wir gefragt werden, ob wir die Änderungen annehmen wollen, klicken wir auf _Apply_.



<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant10.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant10.png "image_tooltip")


Im Sprite Editor klicken wir nun auf _Slice_, um unser Spritesheet zu zerteilen. Nun gibt es mehrere Möglichkeiten ein Sprite zu zerteilen. Wenn man das Sprite im eigenen Bild genau positioniert hat, dann ist es sinnvoll das Sprite manuell zuzuschneiden und zwar im Modus _Grid By Cell Count_. Dabei gebe ich bei C die Anzahl der Spalten und bei R die Anzahl der Zeilen ein. In unserem Fall 3 und 1. Zum Zerteilen bestätigen wir das Ganze mit _Slice_.



<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant11.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant11.png "image_tooltip")


Eine andere Möglichkeit ist, das Sprite automatisch zerteilen zu lassen. Dazu wählen wir als _Type_ _Automatic_ aus und dann bestätigen wir das ganze mit _Slice_. 



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant12.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant12.png "image_tooltip")


Nach dem Slicen geben wir den einzelnen Animationsstufen noch sinnvolle Namen. Hierfür klicken wir auf die jeweilige Animationstufe und geben den jeweiligen Namen ein. (In unserem Fall _Elefant_Stehen_, _Elefant_Gehen_1_, _Elefant_Gehen_2_)

…

<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant13.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant13.png "image_tooltip")



### Die Spielfigur zur Spieleszene hinzufügen

Unser Ziel ist es, einen stehenden Elefant als GameObject dem Spiel hinzuzufügen. Dazu klappen wir zuerst das Sprite Elefant auf, damit die einzelnen Animationsstufen (Elefant_Gehen_1, Elefant_Gehen_2, Elefant_Stehen) angezeigt werden. Durch Ziehen der Animationsstufe _Elefant_Gehen _vom Assetsbereich in den Hierarchy Bereich fügen wir den Elefanten zum Spiel hinzu. Dabei wird auch gleich ein neues GameObject erstellt.

Ist der Elefant hinzugefügt, passen wir noch die Größe an. Das können wir bewerkstelligen, indem wir das Sprite des Elefanten unter _Assets > Sprites _anklicken und im Inspector bei _Pixels Per Unit_ den Wert anpassen (in unserem Fall beispielsweise 300). Mit Apply wird das Ganze wieder bestätigt.



<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant14.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant14.png "image_tooltip")


 


### Speichern der Spieleszene

 Die Spieleszene speichert man, durch einen Klick auf _File/Save Scene _oder mit der Tastenkombination STRG + S. Das gesamte Projekt speichert man mit _File/Save Project._

 

<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant15.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant15.png "image_tooltip")


Mit Play können wir das Spiel starten. Momentan tut sich noch nicht viel, da der Elefant sich noch nicht bewegt und auch Grafiken für den Hintergrund und für die anderen Objekte im Spiel erst hinzugefügt werden. Wir können jedoch das Seitenverhältnis einstellen: Wir wählen das Verhältnis 4:3, da in dem Spiel viel gesprungen wird.



<p id="gdcalert17" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant16.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert18">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant16.png "image_tooltip")



#### Sourcecode	

Download Sourcecode Teil 01: [http://comber.at/dev/BouncyFant01.zip](http://comber.at/dev/BouncyFant01.zip) 


# Teil 2 - Animationen und "States"

Zur Vorbereitung wechseln wir in den Sprite Editor und benennen die in Teil 1 gekennzeichneten Sprites mit aussagekräftigen Namen. Wenn wir das Sprite anklicken (siehe Screenshot), erscheint um den betreffenden Spriteteil ein blauer Rahmen und im rechten Eck erscheint das Eigenschaftsfenster, in dem wir einen aussagekräftigen Namen für den Spriteteil eingeben können.


## States und Animationen 

Bevor wir den Elefanten am Bildschirm hin und her bewegen wollen, legen wir zuerst die Bewegungsabläufe oder Animationen (Stehen und Gehen) für den Elefanten fest. Die Bewegungsabläufe sind durch unterschiedliche Zustände (_States_)  gekennzeichnet.  Ein Zustand ist "Stehen" und der andere Zustand ist "Gehen". 


### Animationen

Animationen werden erstellt, indem man das Sprite aufklappt (siehe Screenshot[^1]), dann die gewünschten Animationsstufen auswählt und vom Projekt-Bereich in den Bereich _Hierarchy_ zieht. Das Erstellen von Animationen funktioniert, wenn man mehrere Animationsstufen in die Hierarchie zieht, in unserem Fall _Elefant_Gehen_1_ und _Elefant_Gehen_2_, automatisch.



<p id="gdcalert18" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant17.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert19">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant17.png "image_tooltip")


Du speicherst die neue Animation im Ordner _Sprites_ und gibst ihr einen sinnvollen Namen.   \
(z.B. _animElefantGehen.anim_)



<p id="gdcalert19" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant18.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert20">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant18.png "image_tooltip")




Durch das Erstellen der Animation per Drag & Drop passieren zwei Dinge automatisch:



1.  Es wird ein Animations-Controller erstellt. Gib diesem einen sinnvollen Namen wie z.B. _AnimationsController_

    

<p id="gdcalert20" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant19.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert21">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant19.png "image_tooltip")


1.  In der Hierarchy wird ein neues Gameobject erstellt. Mit diesem Objekt ist auch der automatisch erstellte AnimationsController verknüpft.

    

<p id="gdcalert21" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant20.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert22">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant20.png "image_tooltip")



    Da wir im Moment nur einen Elefanten brauchen, lösche den Elefanten, den du zu Beginn des Tutorials erstellt hast wieder aus der Hierarchy und benenne das neue Objekt um.


Zusätzlich muss noch eine Animation für den Zustand "Stehen" erzeugt werden. Dies geschieht mittels Rechtsklick auf "Elefant_Stehen" **_> Create > Animation_**.


### Animator

Wenn man diesen Controller doppelt klickt öffnet sich der _Animator_ (_Window/Animator_). Im Animator sind verschiedenen Zustände (_States_) und deren Übergänge definiert.



<p id="gdcalert22" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant21.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert23">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant21.png "image_tooltip")


Neue _States_ kann ich mittels Rechtsklick und _Create/Empty _hinzufügen.



<p id="gdcalert23" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant22.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert24">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant22.png "image_tooltip")


Zuerst wollen wir einen Zustand namens Stehen erzeugen. Dann setzen wir diesen Zustand als Standard _(rechte Maustaste/"Set As Layer Default State")_. Dadurch wird der Zustand orange gekennzeichnet.

Mittels Rechtsklick auf den Zustand und _Make Transition _fügt man neue Übergänge zwischen den Zuständen hinzu.



<p id="gdcalert24" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant23.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert25">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant23.png "image_tooltip")


Am Ende wollen wir die Zustände und Übergänge sowie am Screenshot verbunden zu haben. 



<p id="gdcalert25" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant24.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert26">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant24.png "image_tooltip")


Man kann sich die State Machine tatsächlich wie eine abgeschlossene Maschine vorstellen. Um der State Machine mitzuteilen, in welcher Animationsstufe sich unsere Spielfigur gerade befindet, benötigen wir Parameter. Neue Parameter stellt man im Animator ein, indem man auf _Parameters_ klickt und dann das Plus-Zeichen anklickt. Wir erstellen die Parameter Geschwindigkeit vom Typ _Float _und Springen vom Typ _Bool._ 



<p id="gdcalert26" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant25.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert27">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant25.png "image_tooltip")


Wenn man nun auf Play drückt, wechselt der Elefant von selbst alle paar Sekunden von der stehenden Animation in die Animation des Gehens. Auch wenn sich der Elefant gar nicht hin- und her bewegt, zappelt er mit den Beinen. Damit sich unsere Spielfigur später im Spielen nur dann bewegt, wenn wir auch den Elefanten hin und her bewegen, wollen wir den Übergang von von Stehen zu Gehen und von Gehen zu Stehen an eine Bedingung knüpfen: Ist die horizontale Geschwindigkeit kleiner als 0,01, so soll der Elefant stehen. Ist die horizontale Geschwindigkeit jedoch größer als 0,01, so soll die Animation für die Bewegung abgespielt werden.[^2] Diese Bedingungen legt man unter _Conditions_ fest. Dafür klickt man einfach den Übergang (blauer Pfeil im Screenshot) an und fügt mit dem "+" eine neue Bedingung hinzu. 

Bedingung für den Übergang von Stehen zu Gehen:



<p id="gdcalert27" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant26.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert28">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant26.png "image_tooltip")


Bedingung für den Übergang von Gehen zu Stehen:



<p id="gdcalert28" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant27.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert29">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant27.png "image_tooltip")



### Einstellungen bei den Übergängen

Bei beiden Übergängen müssen wir noch ein paar Einstellungen treffen, damit die Bewegung nicht verzögert auftritt. _Has Exit Time _soll nicht ausgewählt sein, _Fixed Duration _ebenso nicht, die _Transition Duration _und das _Transition Offset _sollten auf 0 gesetzt werden.



<p id="gdcalert29" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant28.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert30">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant28.png "image_tooltip")



#### Sourcecode

Download Sourcecode Teil 02: [http://comber.at/dev/BouncyFant02.zip](http://comber.at/dev/BouncyFant02.zip) 


# Teil 3 - Figuren am Spielfeld bewegen


### Die Bewegung der Elefantin implementieren

Bevor wir mit der Realisierung der Bewegung starten, nennen wir unsere Spielfigur einmal um, damit wir uns später, wenn wir mehrere Figuren haben, besser orientieren können. Ich habe den Namen Elli gewählt. Einfach mit rechten Maustaste draufklicken und auf _Rename _klicken.



<p id="gdcalert30" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant29.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert31">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant29.png "image_tooltip")


Zuerst kümmern wir uns um die Tasten-Eingabe für die Bewegung. Unter _Edit/Project Settings/Input_ kann man den _Input Manager _aufrufen. 

Dort ändern wir die Achsenbezeichnungen (_Horizontal _und_ Vertical_) sowie die Buttons wie im Screenshot dargestellt.



<p id="gdcalert31" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant30.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert32">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant30.png "image_tooltip")


Da wir gerade die Projekteinstellungen geändert haben, ist es wichtig nun auch das Projekt zu speichern. Das geschieht durch das Anklicken von _File _und _Save Project_.



<p id="gdcalert32" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant31.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert33">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant31.png "image_tooltip")



## Rigidbody2D 

Da Elli kein unbewegliches Objekt in unserem Spiel sein wird, brauchen wir eine Komponente, die uns hilft Elli zu bewegen, die Bewegungen zu berechnen und sogar die Physik auf sie wirken zu lassen. Glücklicherweise bietet Unity genau so eine Komponente an, die sich um all die Dinge, wie Bewegung, Berechnung physikalischer Vorgänge und Eigenschaften, Kollisionen, elastische Stöße und dergleichen kümmert. Diese Komponente nennt sich Rigidbody2D. Rigid bedeutet so viel wie "starr", und dass der Körper starr ist, kommt uns sehr gelegen, denn wir brauchen uns nicht darum kümmern, eine ganze Skellettstruktur für Elli zu modellieren.  Einen Rigidbody2D erstellen wir, indem wir im _Hierarchy_-Fenster_ _auf Elli draufklicken und dann im Inspektor auf der rechten Seite auf _Add Component/Physics2D/Rigidbody 2D_ klicken.



<p id="gdcalert33" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant32.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert34">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant32.png "image_tooltip")


Um die Bewegung zu realisieren, benötigen wir ein Script. Dieses Script erstellen wir, indem wir im _Hierarchy_-Fenster_ _auf Elli draufklicken und dann im Inspektor auf der rechten Seite auf _Add Component/NewScript/Create and Add_ klicken.



<p id="gdcalert34" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant33.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert35">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant33.png "image_tooltip")
  

<p id="gdcalert35" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant34.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert36">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant34.png "image_tooltip")


Das eben erstellte Script befindet sich nun im Projekt im Verzeichnis Assets. Wir verschieben es jedoch in das Unterverzeichnis Scripts.

Durch einen Doppelklick auf das Script öffnet sich Visual Studio und wir können nun mit dem Programmieren beginnen. 



<p id="gdcalert36" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant35.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert37">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant35.png "image_tooltip")


Am Anfang nehmen wir in unserem Script ein paar kleine Änderungen vor. In der Kommentarzeile ersetzen wir die englische Anmerkung durch die Zeile _"// Anfangseinstellungen setzen"_  und die Prozedur Update benennen wir in _FixedUpdate_ um. _FixedUpdate_ sorgt nämlich dafür, dass das Spiel auf unterschiedlich schnellen Geräten (egal ob auf einem älteren Notebook, einem Smartphone, oder einem brandneuen Gaming PC) immer gleich schnell läuft. Schnell meint in diesem Fall nicht die Framerate (FPS), sondern wie schnell sich die Spielfigur und die Objekte im Spiel bewegen. Obwohl sich nun die Spielfigur auf allen Plattformen gleich schnell am Bildschirm herum bewegt, hat man auf dem neuen Gaming-Monster-PC eine höhere Framerate als auf einem uralten Notebook. 


```
// Anfangseinstellungen setzen 
void Start ()
{
		
}

// Fixed Update wird immer in einem fixen Intervall aufgerufen.
void FixedUpdate()
{ 

}
```


Der nachfolgende Quellcode, um die Bewegung von Elli zu realisieren, ist ein wenig komplizierter. Deshalb betrachten wir das Einbauen der Prozedur Gehen nun als Übung im Umgang mit dem Quellcode. Im Prinzip machen wir in der Prozedur _Gehen _Folgendes:



1.  Wir berechnen aus dem Wert, den wir aus der horizontalen Eingabe-Achse abfragen, die horizontale (seitliche) Bewegung des Elefantenkörpers. 
1.  Wir bestimmen anhand der Bewegung des Elefantenkörpers die Blickrichtung.
1.  Wir übermitteln die Bewegungsgeschwindigkeit an die Animation in Unity.

Dabei kümmert sich Unity um einige Dinge, um die wir uns nun nicht mehr kümmern brauchen:



1.  Unity übernimmt die Abfrage der Tasten-Eingabe des Spielers für uns.
1.  Unity kümmert sich ebenso um die Bewegung des Elefantenkörpers.

Wir müssen lediglich die aktuelle Geschwindigkeit von Elli unserer Animation übermitteln.

Den nachfolgenden Quellcode kopieren wir zwischen der geschwungenen Klammer am Ende der Prozedur _Start _und den Kommentar vor _FixedUpdate_ hinein. _Anm.: Für diejenigen, die es interessiert, stehen direkt im Quellcode in den Kommentaren Anmerkungen drinnen, in denen erklärt wird, was die nachfolgende Zeile macht. _


```
// Prozedur zum Bewegen des Elefanten
protected void Gehen(float h)
{
    /* Geschwindigkeit setzen
        * Die Geschwindigkeit ergibt sich aus aus der Eingabe für die horizontale
        * Geschwindigkeit und der maximalen Höchstgeschwindigkeit des Elefanten
        */
    Elefantenkoerper.velocity = new Vector2(h * MaxGeschwindigkeit,   Elefantenkoerper.velocity.y);
        
    /* Blickrichtung des Elefanten bestimmen.
        * Der Vektor für die Blickrichtung soll ein Vektor sein,
        * der sich aus dem Vorzeichenrückgabewert (-1 oder +1) 
        * der horizontalen Bewegungsrichtung (Mathf.Sign(h)) ergibt.
        * Der y-Wert des Elefanten bleibt gleich, daher transform.localScale.y.       
        */
    if (h != 0) transform.localScale = new Vector2(Mathf.Sign(h), transform.localScale.y);

    /* Die Geschwindigkeit wird auf den Absolutbetrag der horizontalen
        * Bewegung gesetzt. Negative Geschwindigkeit gibt es nicht.
        * z.B. wenn ich mit dem Auto im Rückwärtsgang 10km/h fahre, fahre ich 
        * 10km/h in einer Rückwärtsbewegung und nicht "-10km/h" ;)
        */
    Animation.SetFloat("Geschwindigkeit", Mathf.Abs(h));
}
```


Nachdem wir dies gemacht haben, erhalten wir vorerst jede Menge Fehler da ja etwa Variablen wie Max Geschwindigkeit oder Objekte wie Elefanten Körper noch gar nicht existieren. 



<p id="gdcalert37" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant36.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert38">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant36.png "image_tooltip")


Diese Variablen wollen wir im nächsten Schritt definieren und gleich in der Prozedur Start mit den entsprechenden Komponenten verlinken: 


```
public class Elli : MonoBehaviour {
    protected Rigidbody2D Elefantenkoerper;
    protected Animator Animation;
    public float MaxGeschwindigkeit = 10;

    // Anfangseinstellungen setzen 
    void Start ()
    {
        // Elefant mit RigidBody verlinken
        Elefantenkoerper = GetComponent<Rigidbody2D>();

        // Eine Referenz auf den Animator hinzufügen
        Animation = GetComponent<Animator>();
    }
```


Nun müssen wir noch in der Prozedur _FixedUpdate_ die vorhin erstellte Prozedur _Gehen_ aufrufen.


```
// Fixed Update wird immer in einem fixen Intervall aufgerufen.
    void FixedUpdate()
    {
        Gehen(Input.GetAxis("H-AchseElli"));
    }
```



```


```


 Der gesamte Quellcode sieht nun wie folgt aus:	


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Elli : MonoBehaviour {
    protected Rigidbody2D Elefantenkoerper;
    protected Animator Animation;
    public float MaxGeschwindigkeit = 10;

    // Anfangseinstellungen setzen 
    void Start ()
    {
        // Elefant mit RigidBody verlinken
        Elefantenkoerper = GetComponent<Rigidbody2D>();

        // Eine Referenz auf den Animator hinzufügen
        Animation = GetComponent<Animator>();
    }

    // Prozedur zum Bewegen des Elefanten
    protected void Gehen(float h)
    {
        /* Geschwindigkeit setzen
            * Die Geschwindigkeit ergibt sich aus aus der Eingabe für die horizontale
            * Geschwindigkeit und der maximalen Höchstgeschwindigkeit des Elefanten
            */
        Elefantenkoerper.velocity = new Vector2(h * MaxGeschwindigkeit, Elefantenkoerper.velocity.y);

        /* Blickrichtung des Elefanten bestimmen.
            * Der Vektor für die Blickrichtung soll ein Vektor sein,
            * der sich aus dem Vorzeichenrückgabewert (-1 oder +1) 
            * der horizontalen Bewegungsrichtung (Mathf.Sign(h)) und 
            * dem Skalierungsfaktor auf der x-Achse ergibt.
            * Der y-Wert des Elefanten bleibt gleich, daher nehmen wir nur den 
            * Skalierungsfaktor "transform.localScale.y".       
            */
        if (h != 0) transform.localScale = new Vector2(Mathf.Sign(h)*Mathf.Abs(transform.localScale.x), transform.localScale.y);

        /* Die Geschwindigkeit wird auf den Absolutbetrag der horizontalen
            * Bewegung gesetzt. Negative Geschwindigkeit gibt es nicht.
            * z.B. wenn ich mit dem Auto im Rückwärtsgang 10km/h fahre, fahre ich 
            * 10km/h in einer Rückwärtsbewegung und nicht "-10km/h" ;)
            */
        Animation.SetFloat("Geschwindigkeit", Mathf.Abs(h));
    }

    // Fixed Update wird immer in einem fixen Intervall aufgerufen.
    void FixedUpdate()
    {
        Gehen(Input.GetAxis("H-AchseElli"));
    }
}
```


Wenn wir nun auf Play drücken und das Spiel starten, dann fällt Elli ins bodenlose Leere. Deshalb setzen wir im Unity-Inspector bei Rigidbody2D von Elli _Gravity Scale_ kurzfristig auf Null. So können wir auch testen, ob wir die Bewegung erfolgreich implementiert haben.



<p id="gdcalert38" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant37.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert39">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant37.png "image_tooltip")



#### Sourcecode

Download Sourcecode Teil 03: [http://comber.at/dev/BouncyFant03.zip](http://comber.at/dev/BouncyFant03.zip) 


# Teil 4 - Ein Level erstellen, Collider verwenden

In diesem Teil wollen wir das Spielfeld, in dem sich die Elefanten bewegen, erstellen. Dazu gehören vorerst die unbeweglichen Spielobjekte und der Hintergrund. Der größte Unterschied zwischen den Spielobjekten und dem Hintergrund ist der, dass die Elefanten mit dem Spielobjekten interagieren können: Spielobjekte können den Elefanten den Weg versperren, einfach als Boden zum drauf stehen dienen oder auch von den Elefanten bewegt werden. 

Als erstes importieren wir die Landschafts-Assets. In unserem Moodle-Kurs findet ihr Assets zum Download, die für die freie Verwendung zur Verfügung stehen. Gerne könnt ihr euch auch eure eigenen Assets erstellen. 



<p id="gdcalert39" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant38.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert40">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant38.png "image_tooltip")


In unserem Beispiel nutzen wir die kostenlosen Tilesets von _Game Art 2D_. Zu finden unter [https://www.gameart2d.com/free-platformer-game-tileset.html](https://www.gameart2d.com/free-platformer-game-tileset.html) [^3]

 



<p id="gdcalert40" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant39.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert41">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant39.png "image_tooltip")


Im Heruntergeladenen Ordner navigieren gehen wir zu _freetileset/png/Tiles_, importieren die Dateien mit den Nummern 2, 13, 14 und 15 und benennen Sie folgendermaßen um:



*   2 -> Boden 
*   13 -> Plattform_Links
*   14 -> Plattform_Mitte
*   15 -> Plattform_Rechts



<p id="gdcalert41" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant40.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert42">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant40.png "image_tooltip")


Die Plattformen ziehe ich einfach via Drag-and-Drop in die Spiel-Szene hinein. 



<p id="gdcalert42" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant41.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert43">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant41.png "image_tooltip")


Die Größe passe ich im Feld _Pixels Per Unit _an.

In der Spielszene kann ich die Plattformen auf zwei Arten verschieben: entweder ich verschiebe die Plattformen mit dem Verschiebepfeil 

<p id="gdcalert43" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant42.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert44">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant42.png "image_tooltip")
 oder ich verschiebe Plattformen, indem ich einen konkreten Wert unter _Transform _bei der _Position_ eingebe.



<p id="gdcalert44" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant43.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert45">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant43.png "image_tooltip")



## Physik und Collider

Ändern wir nun wieder bei Elli _Gravity Scale_ auf 1 und drücken auf Play, dann fällt die Elefantin wieder ins Bodenlose durch die Plattform. Der Grund dafür liegt darin, dass die Plattform noch kein Teil der physikalischen Welt ist. Genau genommen liegt die Ursache darin begründet, dass wir noch keine Collider für die Plattformteile angelegt haben. Ohne Collider ist unsere Plattform nämlich einfach ein Hintergrundobjekt, an dem andere Objekte einfach vorbeiziehen.


#### Collider

Collider stellen in Unity Grenzen für die Kollisionserkennung zur Verfügung. Überschneiden sich die Grenzen von zwei Objekten die Teil der Physik Welt sind, dann wird eine Kollision ausgelöst, dass wird beispielsweise dazu eingesetzt, dass ein Objekt von einem anderen Objekt abprallt oder nicht hindurch kann.

Es gibt in Unity unterschiedliche Arten von Collidern: 



1.  Box Collider
1.  Circle Collider
1.  Edge Collider (für Ränder)
1.  Composite Collider 
1.  Capsule Collider 
1.  Polygon Collider

Die einfachsten Collider sind _Box Collider_ und _Circle Collider_. Mit Einfachheit ist nicht nur die Einfachheit der Form gemeint, sondern auch, wie einfach Kollisionsereignisse zu berechnen sind. Bei Box und Circle sind Kollisionsereignisse mit weniger Aufwand zu berechnen, als bei komplizierten Formen, die etwa Polygon-Collider verwenden. Deshalb sollte man nach Möglichkeit eher einfache Collider verwenden. Verwendet man zu viele komplizierte Collider kann dies die Framerate verringern, bzw. zu Ruckeln führen.

Um das Konzept des Geschwindigkeitsvorteils von einfachen Collidern anzuwenden, fügen wir der _Plattform_Links _nun statt einem _Polygon Collider_, zwei _Box Collider_ hinzu. 

Dafür klicken wir im Inspector auf _AddComponent/Physics2D/Box Collider 2D._

Wir optimieren noch das _Offset _und die Werte bei Size.

Box Collider 1



<p id="gdcalert45" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant44.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert46">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant44.png "image_tooltip")


Box Collider 2



<p id="gdcalert46" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant45.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert47">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant45.png "image_tooltip")


Alternativ kann man auch auf den Button neben Edit Collider klicken und den Collider durch Ziehen mit der Maus anpassen.



<p id="gdcalert47" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant46.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert48">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant46.png "image_tooltip")


Nachfolgend unser Plattformteil mit den Collider-Grenzen der zwei Box-Collider in grün.



<p id="gdcalert48" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant47.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert49">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant47.png "image_tooltip")
 

Anmerkung: Zuvor habe ich über das _Konzept des Geschwindigkeitsvorteils _bei Collider geschrieben. Ich habe deswegen zuvor in der Formulierung das _Konzept _verwendet, weil in der Praxis so einfache Objekte wie unsere Plattformen, noch dazu, wenn sie in so geringer Zahl sind und sich darüber hinaus statisch, also fix in der Landschaft sind, locker mit der Rechenleistung von älteren Computern, Konsolen oder Smartphones auskommen. Dennoch halte ich es für wichtig, dass man gerade im Simulationsbereich oder im Bereich der Computergrafik über Effizienz von Berechnungen oder Algorithmen ein wenig nachdenkt. 

Für das mittlere Plattformstück reicht ein _Box Collider_. Für das rechte Plattformobjekt habe ich diesmal die _Box Collider _nicht überschneidend sondern einfach übereinandergelegt gestaltet.



<p id="gdcalert49" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant48.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert50">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant48.png "image_tooltip")
 

<p id="gdcalert50" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant49.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert51">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant49.png "image_tooltip")


Abschließend machen wir uns noch das weitere Gestalten des Levels leichter, indem wir ein neues Game Objekt erstellen in das wir alle drei Teile der Plattform hinein verschieben, so dass sie gruppiert sind. Dazu klicke ich mit der rechten Maustaste in den Hierarchy Bereich und wähle aus dem Kontextmenü _Create Empty_. Das neue _GameObject _benennen wir dann gleich in _Plattform _um und schieben die einzelnen Plattformteile in das _GameObject _Plattform. Die so gruppierten Plattformen kann man nun einfach mit der rechten Maustaste duplizieren und beliebig am Spielfeld verteilen.



<p id="gdcalert51" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant50.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert52">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant50.png "image_tooltip")


Am Ende sollte das Spielfeld in etwa so aussehen.



<p id="gdcalert52" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant51.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert53">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant51.png "image_tooltip")


Das graue Rechteck stellt den momentanen Kameraausschnitt dar. Dieser Ausschnitt bestimmt wie viel Platz wir am Spielfeld haben. Ist uns der Platz am Spielfeld zu gering, so können wir einfach durch einen Klick auf _Main Camera_ (zu finden in der _Hierarchy_) die Eigenschaften der Kamera im _Inspector _anzeigen. In den Eigenschaften ändern wir einfach die Größe (_Size_) auf einen höheren Wert, z.b. 7. 



<p id="gdcalert53" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant52.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert54">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant52.png "image_tooltip")


Der Elefantendame Elli gönnen wir am Ende noch einen _Polygon Collider_. 



<p id="gdcalert54" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant53.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert55">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant53.png "image_tooltip")


Beim Hauptcharakter unseres Spiels kann man schließlich ein wenig mehr Rechenaufwand in Kauf nehmen und die genauen Grenzen, wie etwa beim Rüssel, machen dann die ganze Physik-Simulation viel spaßiger beim Spielen.



<p id="gdcalert55" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant54.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert56">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant54.png "image_tooltip")



## Spielfeldgrenzen

Um das Spielfeld zu begrenzen gibt es mehrere Möglichkeiten:



1.  Wir fügen einen Collider zur Kamera hinzu.
1.  Wir erstellen für jede Spielfeldgrenze ein eigenes _Game Object_ und fügen dem Objekt den jeweiligen Collider hinzu.
1.  Wir erstellen ein einziges _Game Object _und fügen diesem Objekt alle vier Spielfeldbegrenzungen zu.

In diesem Beispiel wählen wir Variante 3, erstellen einen neues Game Object, benennen es in Spielfeldgrenzen um und fügen dem soeben erstellten Objekt vier _Box Collider 2D _hinzu.



<p id="gdcalert56" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant55.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert57">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant55.png "image_tooltip")


Wie man sehen kann, gehen die Spielfeldgrenzen oben ein wenig über den Bildauschnitt, den die Kamera darstellt, hinaus. Dadurch können die Elefanten nach oben ein wenig über den Rand hinaus springen was vom Spiel-Feeling her ganz angenehm ist.



<p id="gdcalert57" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant56.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert58">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant56.png "image_tooltip")


Folgende Werte für _Offset _und _Size _tragen wir bei den einzelnen Box Collider ein:


<table>
  <tr>
   <td>Position des Colliders
   </td>
   <td>Offset X
   </td>
   <td>Offset Y
   </td>
   <td>Size X
   </td>
   <td>Size Y
   </td>
  </tr>
  <tr>
   <td>Oben
   </td>
   <td>0
   </td>
   <td>8,5
   </td>
   <td>20
   </td>
   <td>1
   </td>
  </tr>
  <tr>
   <td>Unten
   </td>
   <td>0
   </td>
   <td>-6,8
   </td>
   <td>20
   </td>
   <td>1
   </td>
  </tr>
  <tr>
   <td>Links
   </td>
   <td>-9,6
   </td>
   <td>1
   </td>
   <td>1
   </td>
   <td>16
   </td>
  </tr>
  <tr>
   <td>Rechts
   </td>
   <td>9,6
   </td>
   <td>1
   </td>
   <td>1
   </td>
   <td>16
   </td>
  </tr>
</table>



### Bodenlegen 

Jetzt fällt Elli zumindest nicht mehr aus dem Spielfeld heraus. Doch auf einem unsichtbaren Bodens gehen hat nur halb so viel Stil. Deshalb werden wir uns jetzt einen schönen Boden legen, der sich genau mit der Grenze des unteren Spielfeldcolliders deckt. 

Zuerst änderen wir die Größe des Sprites für den Boden auf 170 _pixels per unit_  und ziehen dann das Boden-Sprite in die Szene hinein. _Das Ganze machen wir nun in etwa 30 Mal. Dabei bekommt man richtig viel Übung ;-)  Halt, Nein, Scherz! _Als InformatikerInnen lieben wir Effizienz und elegante Konstrukte und deshalb verwenden wir für das Erstellen der weiteren Bodenteile eine Schleife.



<p id="gdcalert58" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant57.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert59">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant57.png "image_tooltip")



### Vorlagen

Wollen wir mittels Script neue Objekte erstellen, dann können wir uns Arbeit ersparen, indem wir Vorlagen verwenden. Eine Vorlage erstellt man einfach dadurch, dass man aus der _Hierarchy _ein vorhandenes _Game Object _in den Projektbereich zieht. Wir ziehen also das _Game Object _ Boden in das Verzeichnis Vorlage und schon haben wir eine Vorlage.



<p id="gdcalert59" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant58.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert60">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant58.png "image_tooltip")


Dem Objekt Spielfeldgrenzen fügen wir nun mittels _Add Component _ein neues Script hinzu, das wir Spielfeld nennen. Dieses Script verschieben wir auch gleich wieder in den Ordner Scripts.



<p id="gdcalert60" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant59.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert61">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant59.png "image_tooltip")


Das Script klicken wir doppelt an und nun sollte sich Microsoft Visual Studio öffnen. In Visual Studio löschen wir im Script Spielfeld zuerst die Prozedur Update. Dann fügen wir gleich unter der Klassendefinition ein Spielobjekt namens Boden hinzu und speichern das Script mit Strg+s


```
public class Spielfeld : MonoBehaviour {
    public GameObject Boden;
```


Ganz wichtig ist es dem Feld Boden das bei uns in Unity Inspector auftaucht, nun auch die Vorlage zuzuweisen. Dies bewerkstelligen wir, indem wir die zuvor angelegte Vorlage in das entsprechende Feld im Script ziehen.  _Anm.: Scheint das Feld Boden beim Script nicht auf, liegt das evtl. daran, dass das Script noch nicht gespeichert wurde._



<p id="gdcalert61" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant60.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert62">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant60.png "image_tooltip")


Schließlich erstellen wir die Prozedur für das Zeichnen des Bodens. Dabei wird neu Boden instanziiert und eine bestimmte Position gesetzt. 


```
// In dieser Prozedur wird der Boden gezeichnet
public void ZeichnenBoden(int x)
{
   Instantiate(Boden, new Vector3(x * 0.75f, -6.81f, -4), Quaternion.identity);
}
```



### Aufgabe 

Füge in die vorhandenen Prozedur _Start _eine Schleife ein, die die Bodenstücke am am unteren Rand des Spielfelds automatisch zeichnet. 


```
// Initialisierungen
void Start ()
{
    // In dieser Schleife wird der Boden gezeichnet
    /*** Hier den Code für die Schleife einfügen ***/ 
}
```


Eine mögliche Lösung sieht so aus:


```
for (int i = -20; i <= 20; i++) ZeichnenBoden(i);
```


Obige Version ist die Kurzform und gleichwertig mit der Langform mit den geschwungenen Klammern:

 


```
for (int i = -20; i <= 20; i++)
{
    ZeichnenBoden(i);
}     
```


Zum Abschluss noch einmal der ganze Quellcode des Scripts Spielfeld.cs:


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Spielfeld : MonoBehaviour {
    public GameObject Boden;

    // Initialisierungen
    void Start ()
    {
        // In dieser Schleife wird der Boden gezeichnet
        for (int i = -20; i <= 20; i++) ZeichnenBoden(i);
    }

    // In dieser Prozedur wird der Boden gezeichnet
    public void ZeichnenBoden(int x)
    {
        Instantiate(Boden, new Vector3(x * 0.75f, -6.81f, -4), Quaternion.identity);
    }
}
```


Das Resultat sieht dann so aus.



<p id="gdcalert62" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant61.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert63">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant61.png "image_tooltip")



## Hintergrund und Abschlussaufgaben

Zum Abschluss haben wir die letzten Schritte des Leveldesign als Übung für dich ausgedacht. Dabei geht es darum Dinge anzuwenden, die in diesem Kapitel besprochen wurden. 


### Aufgabe 

Füge der Spieleszene den Hintergrund BG.png aus _freetileset_jungle\png\BG_ ([Download](https://www4.lernplattform.schule.at/g16slsz/pluginfile.php/10141/mod_url/intro/freetileset_jungle.zip))  hinzu. 

In Moodle wird man dann die Lösung ein/ausblenden können.

Lösung Aufgabe 1



1.  Rechtsklick in den Assetbereich/_Import New Asset. _Auswählen von f_reetileset_jungle\png\BG\BG.png \
_

<p id="gdcalert63" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant62.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert64">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant62.png "image_tooltip")

1.  Die Grafik vom Projektbereich in die _Hierarchy _ziehen und in Hintergrund umbenennen.
1.  Die Grafik (Hintergrund) anklicken und anpassen. Dazu im _Inspector _folgende Werte setzen:
    1.  Position: X=0, Y=0, Z=10
    1.  Größe: Im _Inspector _Scale auf folgenden Werte setzen: X=2, Y=2, Z=1. Fertig!


### Aufgabe 2

Füge die Grafik Tree3.png aus dem _freetileset_jungle\png\Object_ zur Spielszene hinzu und Weise dem Baum einen _Polygon Collider 2D _zu. 



Lösung Aufgabe 2:



1.  Rechtsklick in den Assetbereich/_Import New Asset. _Auswählen von _freetileset_jungle\png\Object\Tree_3.png_
1.  Die Grafik vom Projektbereich in die _Hierarchy _ziehen und in _Baum _umbenennen.
1.  Die Grafik (Hintergrund) anklicken und anpassen. Dazu im _Inspector _folgende Werte setzen:
    1.  Position: X=0, Y=0, Z=10
    1.  Größe: Im _Inspector _Scale auf folgenden Werte setzen: X=2, Y=2, Z=1. Fertig!
1.  In der _Hierarchy _den Baum anklicken und im _Inspector _über _Add Component/Physics 2D/Polygon Collider 2D _ den Collider hinzufügen! Fertig!


### Pro-Tipp

Wenn man möchte, dass die Objekte im Spielfeld ein wenig in der Baumkrone verschwinden, dann kann man die Größe des Objekts z.B. Tree_3 zuerst auf einen höheren Wert setzen (z.B. 110) und dann den Collider hinzufügen. Ein höherer Wert bei Pixelgröße bedeutet ja, dass der Baum kleiner dargestellt wird. Dadurch haben wir einen etwas kleineren Baum mit einem kleineren Collider. Wenn wir jetzt die Pixelgröße wieder auf den ursprünglichen Wert von 100 zurücksetzen, dann bleibt der Collider kleiner als die graphische Darstellung des Baums. Der Collider skaliert nämlich nur dann mit, wenn ich die Größe eines Spielobjekts via _Transform/Scale_ ändere. Für das Finetuning könnte man noch das Offset des Polygon Colliders anpassen, z.B. indem wir Y=-0,1 setzen. Abschließend setzt man noch den Z-Wert des Baums auf einen niedrigeren Z-Wert, als den Wert der anderen Spielobjekte (z.B. -2).


#### Sourcecode

Download Sourcecode Teil 04: [http://comber.at/dev/BouncyFant04.zip](http://comber.at/dev/BouncyFant04.zip) 


# Teil 5 - Eine zweite Spielfigur erstellen


## Objektorientierte Programmierung, Vererbung

In diesem Kapitel erstellen wir eine zweite Spielfigur. Wir möchten jedoch nicht einfach eine Kopie der vorhandenen Spielfigur erstellen, sondern wir möchten eine Parent-Klasse erstellen von der wir dann die Child-Klassen ableiten.



<p id="gdcalert64" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline drawings not supported directly from Docs. You may want to copy the inline drawing to a standalone drawing and export by reference. See <a href="https://github.com/evbacher/gd2md-html/wiki/Google-Drawings-by-reference">Google Drawings by reference</a> for details. The img URL below is a placeholder. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert65">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![drawing](https://docs.google.com/a/google.com/drawings/d/12345/export/png)

Dazu ist es hilfreich über die grundlegenden Prinzipien der objektorientierten Programmierung Bescheid zu wissen. Wer sich noch einmal die Grundlagen der objektorientierten Programmierung durchlesen möchte, kann diese in unserem Moodle-Kurs unter diesem Link finden: [Lernmaterialien über objektorientierte Programmierung](https://www4.lernplattform.schule.at/g16slsz/mod/book/view.php?id=5818) 


### Einführende Übung

Überlegt in Gruppen zu je vier Personen, welche Vorteile eine Vorlage einer Spielfigur, von der dann die weiteren Spielfiguren abgeleitet sind, bringt. Notiert eure Ergebnisse auf einem Medium (Papier, PC, Smartphone) eurer Wahl.


##### Mögliche Vorteile (Beispielantworten)



*   Der Quellcode wird strukturierter und übersichtlicher.
*   Man kann durch Vererbung gemeinsame Eigenschaften und gemeinsames Verhalten teilen Muss den Quellcode nicht doppelt implementieren/kopieren.
*   Änderungen in der Vorlage wirken sich automatisch auf die abgeleiteten Objekte aus. Man muss nicht jede Änderung für jede Spielfigur durchführen. 


## Ein neues Objekt "BouncyFant" erstellen

Das neue Objekt, dass wir benötigen, realisieren wir einfach in einem Script. Dazu erstellen wir in unserem Script-Verzeichnis das Script _BouncyFant.cs_.



<p id="gdcalert65" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant63.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert66">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant63.png "image_tooltip")


Die Methoden_ Start _und _Update _können wir löschen, da wir sie in der übergeordneten Klasse nicht benötigen.

Nun verschieben (Ausschneiden - STRG + X ) wir von Elli alle Variablen und Methoden, die allen Elefanten gemeinsam sein sollen, in die Klasse _BouncyFant_. Am Ende soll unsere Klasse _BouncyFant _nun so aussehen:


<table>
  <tr>
   <td><code>using System.Collections; \
using System.Collections.Generic; \
using UnityEngine; \
 \
public class BouncyFant : MonoBehaviour { \
    protected Rigidbody2D Elefantenkoerper; \
    protected Animator Animation; \
    public float MaxGeschwindigkeit = 10;</code>
<p>
<code>    public string Name; \
 \
    <em>// Prozedur zum Bewegen des Elefanten</em> \
    protected void Gehen(float h) \
    { \
        <em>/* Geschwindigkeit setzen \
            * Die Geschwindigkeit ergibt sich aus aus der Eingabe für die horizontale \
            * Geschwindigkeit und der maximalen Höchstgeschwindigkeit des Elefanten \
            */</em> \
        Elefantenkoerper.velocity = new Vector2(h * MaxGeschwindigkeit, Elefantenkoerper.velocity.y); \
 \
        <em>/* Blickrichtung des Elefanten bestimmen. \
            * Der Vektor für die Blickrichtung soll ein Vektor sein, \
            * der sich aus dem Vorzeichenrückgabewert (-1 oder +1)  \
            * der horizontalen Bewegungsrichtung (Mathf.Sign(h)) ergibt. \
            * Der y-Wert des Elefanten bleibt gleich, daher transform.localScale.y.        \
            */</em> \
        if (h != 0) transform.localScale = new Vector2(Mathf.Sign(h), transform.localScale.y); \
 \
        <em>/* Die Geschwindigkeit wird auf den Absolutbetrag der horizontalen \
            * Bewegung gesetzt. Negative Geschwindigkeit gibt es nicht. \
            * z.B. wenn ich mit dem Auto im Rückwärtsgang 10km/h fahre, fahre ich  \
            * 10km/h in einer Rückwärtsbewegung und nicht "-10km/h" ;) \
            */</em> \
        Animation.SetFloat("Geschwindigkeit", Mathf.Abs(h)); \
    } \
}</code>
   </td>
  </tr>
  <tr>
   <td>
   </td>
  </tr>
</table>


Damit Elli die Methoden und Variablen der Parent-Klasse _BouncyFant _ auch nutzen kann, teilen wir dem Compiler mit, dass Elli eine Child-Klasse von _BouncyFant _ist.Dies bewerkstelligen wir, indem wir die oberste Zeile der Klasse Elli ändern.


```
public class Elli : BouncyFant {


```


Die Klasse Elli sieht nun so aus:


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Elli : BouncyFant {
    // Anfangseinstellungen setzen 
    void Start ()
    {
        // Den Namen setzen
        Name = "Elli";

        // Elefant mit RigidBody verlinken
        Elefantenkoerper = GetComponent<Rigidbody2D>();

        // Eine Referenz auf den Animator hinzufügen
        Animation = GetComponent<Animator>();
    }

    // Fixed Update wird immer in einem fixen Intervall aufgerufen.
    void FixedUpdate()
    {
        Gehen(Input.GetAxis("H-AchseElli"));
    }
}
```


In  der Prozedur Start, fügen wir unter der Zeile `Animation = GetComponent<Animator>(); `noch den Quellcode ein, um die Farbe von Elli auf einen leichten rötlichen Ton zu ändern.


```
// Setzen von Ellis Farbe auf einen leichten Rotton - Color(Rot, Grün, Blau)
GetComponent<SpriteRenderer>().color = new Color(0.96f, 0.85f, 0.8f);
```


Jetzt können wir  uns bereits um Ellis Begleiter kümmern. Zuallererst klicken wir in der Hierarchy mit der rechten Maustaste auf Elli und duplizieren das _GameObject _Elli.


# 

<p id="gdcalert66" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant64.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert67">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant64.png "image_tooltip")


Das neue _GameObject_ benennen wir nun um, beispielsweise in _Ossi_. 

Der Elefant Ossi benötigt ein eigenes Script. Durch das Duplizieren des Objekts Elli ist auch noch Elli Script in Ossi enthalten. Dieses Script löschen wir im Inspector.

<p id="gdcalert67" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant65.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert68">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant65.png "image_tooltip")


Ossis neues Script erstellen wir_ _via _Add Component/New Script _ebenfalls im _Inspector_. Doch einen Doppelklick auf das Script öffnet sich wieder Visual Studio.  Wann legen wir zuerst fest, dass Ossi  von der Klasse BouncyFant abgeleitet wird:


```
public class Ossi : BouncyFant {
```


Die anderen Quellcodeteile können wir aus _Elli.cs_ kopieren. Dabei ändern wir nur die Zeile mit der Farbe und die Zeile mit der Eingabeachse, sodass unser Quellcode schließlich so aussieht.


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Ossi : BouncyFant {
    // Anfangseinstellungen setzen 
    void Start()
    {
        // Den Namen setzen
        Name = "Ossi";

        // Elefant mit RigidBody verlinken
        Elefantenkoerper = GetComponent<Rigidbody2D>();

        // Eine Referenz auf den Animator hinzufügen
        Animation = GetComponent<Animator>();

        // Setzen von Ossis Farbe auf einen leichten Blauton - Color(Rot, Grün, Blau)
        GetComponent<SpriteRenderer>().color = new Color(0.76f, 0.86f, 0.98f);
    }

    // Fixed Update wird immer in einem fixen Intervall aufgerufen.
    void FixedUpdate()
    {
        Gehen(Input.GetAxis("H-AchseOssi"));
    }
}
```


Gerne könnt ihr probieren, wie das Spiel läuft, wenn ihr die Eingabe Achse nicht ändert. Dann steuern sich die Elefanten wunderbar synchron - beide mit den Tasten A und D.

Jetzt wo wir schon die Eingabe Achse geändert haben sollten wir auch gleich in den Projekteigenschaften die veränderte Achse definieren. Das bewerkstelligen wir wieder in den Input Settings. 


# 

<p id="gdcalert68" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant66.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert69">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant66.png "image_tooltip")
 

In den _Input Settings _(im _Inspector_)_ _finden wir zwei weitere Achsen, die _Horizontal _und _Vertical_ heißen. 



<p id="gdcalert69" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant67.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert70">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant67.png "image_tooltip")


Diese Achsen benennen wir in _H-AchseOssi_ und _V-AchseOssi _um und ändern folgende Einstellungen:



*   H-AchseOssi
    *   Negative Button: _left_
    *   Positiv Button:_ right_
    *   Type: _Key or Mouse Button_
*   V-AchseOssi
    *   Negative Button: _down_
    *   Positiv Button:_ up_
    *   Type: _Key or Mouse Button_



<p id="gdcalert70" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant68.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert71">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant68.png "image_tooltip")


Das war's auch schon. Jetzt sind beide Elefanten unabhängig voneinander steuerbar, Elli mit den Tasten A und D und Ossi mit den Pfeiltasten.


#### Sourcecode

Download Sourcecode Teil 05: [http://comber.at/dev/BouncyFant05.zip](http://comber.at/dev/BouncyFant05.zip) 


# Teil 6 - "Jump Around!", erweiterte Bewegungsfunktionalität und Materialien hinzufügen 

Wir haben unser Spiel ja nicht umsonst BouncyFant genannt. In diesem Teil wollen wir uns darum kümmern, den Elefanten die Fähigkeit zu verleihen am Spielfeld wie Flummis herumspringen zu können. Dazu gehört erstmal die prinzipielle Möglichkeit springen zu können und später das richtige Material, um die Elefanten elastisch werden zu lassen. 


## Springen


### Sprungkraft

Zuallererst bauen wir in _BouncyFant.cs_ die Variable Sprungkraft ein, um einstellen zu können, wie hoch die Elefanten springen können. 


```
public class BouncyFant : MonoBehaviour {
    protected Rigidbody2D Elefantenkoerper;
    protected Animator Animation;
    public float MaxGeschwindigkeit = 10;
    public float Sprungkraft = 300;
```


_Anm: Solltet ihr dieses Spiel mit eurer Biologielehrerin programmieren, dann setzt die Variable Sprungkraft immer auf 0. ;-)_


### Feststellen, ob sich der Elefant am Boden befindet

Grundsätzlich wollen wir, dass die Elefanten nur dann springen können, wenn sie sich auf einem Objekt befinden, von dem man auch wegspringen kann.  _Könnten Ossi und Elli nämlich aus der Luft nochmal los springen, wäre das ziemlich gecheatet.  Es spricht aber nichts dagegen, dass man in einem anderen Spiel, einem anderen Level unseres Spiels oder bei Boostern, so ein Feature (z.B. Double Jump, oder ein Art Flappybird-Mechanik) einbaut. _

Die Funktion zum Feststellen, ob ein Elefant springen kann/am Boden steht, bauen wir nun ins Script _BouncyFant.cs _ein, damit es für alle Elefanten zu Verfügung steht.


```
// Feststellen, ob der Elefant am Boden ist.
protected bool AmBoden()
{
	// Abfragen der Grenzen der Kollisionsobjekte
	Bounds Grenze = GetComponent<Collider2D>().bounds;
	float Spielraum = Grenze.size.y * 0.1f;

	// Berechnen einer Position die ein wenig unter der Kante des Kollisionsobjekts liegt
	// sonst kann es vorkommen, dass der Elefant nicht springen kann, wenn er ganz still steht.
	Vector2 v = new Vector2(Grenze.center.x, Grenze.min.y - Spielraum);

	// Kollisionsabfrage:  mittels einer Linie  
	RaycastHit2D Kollision = Physics2D.Linecast(v, Grenze.center);

	// "true" zurückgeben, wenn das Kollisionsobjekt nicht der Elefant selbst ist.
	return (Kollision.collider.gameObject != gameObject);
}
```


 Gleich darunter implementieren wir die Methode Springen. 


```
// Springen
protected void Springen(KeyCode Taste)
{
	// Herausfinden, ob der Elefant irgendwo steht, von wo er abspringen kann
	bool springenmoeglich = AmBoden();

	/* Wenn der Pfeil nach oben gedrückt wird und Springen möglich, 
	 * d.h. der Elefant hat etwas, von wo er aus wegspringen kann,
	 * dann bekommt der Elefantenkörper einen Impuls (Addforce), 
	 * entsprechend der von uns gewählten Sprungkraft 
	 */
	if (Input.GetKey(Taste) && springenmoeglich)
		Elefantenkoerper.AddForce(Vector2.up * Sprungkraft);

	/*
	 * Wenn der Elefant gerade springt, dann springen auf nicht möglich setzen.
	 * Nicht = Rufzeichen(!). 
	 */
	Animation.SetBool("Springen", !springenmoeglich);
}
```


Unsere Elefanten rufen die Prozedur _Springen _mit der entsprechenden Taste in Klammer, mit der gesprungen werden soll, in _FixedUpdate() _auf.

Elli


```
void FixedUpdate()
{
	Gehen(Input.GetAxis("H-AchseElli"));
	Springen(KeyCode.W);
}
```


Ossi


```
void FixedUpdate()
{
	Gehen(Input.GetAxis("H-AchseOssi"));
	Springen(KeyCode.UpArrow);
}
```



## Elastisches Material

Um die Flummi-Eigenschaften zu realisieren, erstellen wir ein neues Material, das wir so konfigurieren, dass es elastische Eigenschaften aufweist. 



<p id="gdcalert71" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant69.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert72">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant69.png "image_tooltip")


Mit der Elastizität _(Bounciness), _ könnt ihr gerne herumexperimentieren. Außerdem geben wir dem Material noch einen aussagekräftigen Namen._ _



<p id="gdcalert72" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant70.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert73">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant70.png "image_tooltip")


Das Material weisen wir zu, indem wir es einfach in das GameObject ziehen.  Es erscheint dann auch automatisch beim _Polygon Collider 2D_ als Material.



<p id="gdcalert73" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant71.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert74">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant71.png "image_tooltip")



#### Sourcecode

Download Sourcecode Teil 06: [http://comber.at/dev/BouncyFant06.zip](http://comber.at/dev/BouncyFant06.zip) 


# Teil 7 - Objekte der Physikwelt hinzufügen 

Wer die Background Story unseres Spiels gelesen hat, der weiß, dass der böse Dr. Scramblewoods alles daran setzen wird, Elli und Ossi daran zu hindern, seine Maschinen zu deaktivieren und den Regenwald zu retten. Deshalb legt Dr. Scramblewoods den Bouncy Fants alle möglichen Hindernisse in den Weg. Im ersten Level lässt er sperrige Kisten und Kugeln auf sie herab regnen, damit sie den magischen Pilz nicht erreichen.


#### Add some trash

Um den herabfallenden Sperrmüll zu erstellen, legen wir wieder jeweils ein neues Asset _(Import New Asset)_ im Projektbereich an und  ziehen die Kisten und Kugeln in die Spieleszene.



<p id="gdcalert74" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant72.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert75">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant72.png "image_tooltip")


Sowohl Kugel als auch Kiste bekommen einen entsprechenden Collider (die Kugel einen Circle Collider und die Kiste einen Box Collider) zugewiesen. Damit sich die Kisten und Kugeln auch bewegen können und nicht starr im Level verharren und somit die Gravitation wirken kann, versehen wir sie mit einem _RigidBody2D_. 


### Skalieren

Die Größe von Kiste und Kugel haben wir in unserem Spiel noch um den Faktor 1,55 jeweils auf der X- und Y-Achse skaliert. 



<p id="gdcalert75" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant73.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert76">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant73.png "image_tooltip")


_Pro-Tipp: Ganz allgemein ist es im Spiel sinnvoll, wenn man die Größe der Objekte im Spiel durch die Skalierung ändert. Diese Art der Größenänderung wirkt sich nämlich auch auf die Größe des Colliders aus.  Was spricht gegen die Größenänderung via Pixelgröße:  Würden wir die Größe von Elli, jetzt wo wir bereits den Collider hinzugefügt haben, mit Hilfe der Pixelgröße verkleinern, dann würde sie bereits an Objekten anstoßen bevor sie diese berührt und nicht weiter können, da der Collider bereits eine Kollision meldet._

Nun ziehen wir das zuvor erstellte elastische Material aus dem Ordner _Material _auf die Kisten auf die Kugel, damit diese auch herumspringen. Um viele Kisten und Kugeln zu erstellen, kreieren wir uns wieder eine Vorlage. Zu diesem Zweck ziehen wir die Kugel und die Kiste in den Ordner _Vorlagen._



<p id="gdcalert76" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant74.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert77">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant74.png "image_tooltip")


Jetzt fehlt noch die Implementierung für die herabfallenden Gegenstände. Damit wir schon jetzt unser Spiel dafür vorbereiten, dass es unterschiedliche Level geben wird, erstellen wir ein neues _GameObject _mit dem Namen _Level01._



<p id="gdcalert77" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant75.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert78">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant75.png "image_tooltip")


Wir erstellen im GameObject _Level01 _ein Script und nennen es _Muell.cs_. Dieses Script soll so aussehen (der Quellcode wird später noch im Detail genau erklärt). 


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Muell : MonoBehaviour {

    // Konstanten für die Maximalanzahl der Kisten definieren
    const int MAXANZAHLKISTEN = 30;
    const int MAXANZAHLKUGELN = 45;

    // Zählvariablen Kisten
    int Anzahlkisten = 0, Anzahlkugeln = 0;

    // Erstellen der GameObjekte für Kisten und Kugeln
    public GameObject Kiste;
    public GameObject Kugel;


    // Initialisierungen
    void Start()
    {
        InvokeRepeating("ErzeugeKiste", 1, 1);
        InvokeRepeating("ErzeugeKugel", 0.5f, 1);
    }

    // Erzeuge an einer Zufallsposition eine Kugel
    void ErzeugeKugel()
    {
        if (Anzahlkugeln < MAXANZAHLKUGELN)
        {
            // Zufallszahl zwischen dem linken und dem rechten Rand generieren
            int x = (int)Random.Range(-13, 13);

            // Instanzieren der Kugel an der Position x,y
            Instantiate(Kugel, new Vector2(x, 8.0f), Quaternion.identity);

            // Anzahl der Kugeln um 1 erhöhen
            Anzahlkugeln++;
        }
    }
    // Erzeuge an einer Zufallsposition eine Kiste
    void ErzeugeKiste()
    {
        if (Anzahlkisten < MAXANZAHLKISTEN)
        {
            // Zufallszahl zwischen dem linken und dem rechten Rand generieren
            int x = (int)Random.Range(-13, 13);

            // Instanzieren der Kiste an der Position x,y
            Instantiate(Kiste, new Vector2(x, 8.0f), Quaternion.identity);

            // Anzahl der Kugeln um 1 erhöhen
            Anzahlkisten++;
        }
    }
}
```


Wenn alles gespeichert ist, weisen wir im Inspector dem _Level01 _die Vorlagen den Variablen _Kiste _und _Kugel _zu.



<p id="gdcalert78" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant76.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert79">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant76.png "image_tooltip")



### Sourcecode

Download Sourcecode Teil 07: [http://comber.at/dev/BouncyFant07.zip](http://comber.at/dev/BouncyFant07.zip) 


# Teil 8 - Play to compete, cooperate to win!


## Die Spielmechanik

Im ersten Level ist es das Ziel, einen magischen Pilz zu erreichen. Diejenige, die zuerst den Pilz erreicht bekommt einen Punkt. Das erste Level ist geschafft, wenn einer der Elefanten 10 Punkte erreicht hat. Die Zusammenarbeit kann aber über das bloße, gemeinsame Sammeln von Punkten auch hinausgehen. Beispielsweise könnt ihr euch helfen, den Pilz zu erreichen, etwa indem ihr euch gegenseitig in die Luft katapultiert und so höhere Sprünge machen könnt. _Anm: Eine weitere Idee um die Kooperation der SpielerInnen zu fördern: Je schneller man die zehn Punkte beisammen hat, desto höher sind die Bonuspunkte, die man am Ende des Levels bekommt. Später kann es sogar sein, dass einige Levels gar nicht schaffbar sind, ohne das Elli und Ossi zusammen arbeiten. Eurer Fantasie sind dabei keine Grenzen gesetzt, be creative! _ Doch nun zurück zu unserem Vorhaben: Lassen wir einen magischen Pilz entstehen, der, wenn er berührt wird, einen Punkt für den jeweiligen Bouncy Fant bringt. 


## Der Zauberpilz und seine Eigenschaften

Bisher ist es zwar möglich, mit den Elefanten hin- und her zu springen, während es Kisten und Kugeln regnet. Ziel des Spiels ist es jedoch den magischen Pilz zu erreichen. Zum Einstieg beginnen wir gleich mit einer Aufgabe, deren Lösungsweg wir schon aus den vorigen Kapiteln kennen.


### Aufgabe 3

Füge dem Spiel auf der obersten Plattform die Grafik _(freetileset_jungle\png\Object\Mushroom_2.jpg) _des magischen Pilzes hinzu. _Anmerkung: das Tileset findest du in unserem Moodle Kurs oder bei [Open Game Art](https://www.gameart2d.com/free-platformer-game-tileset.html). Wenn du die vorigen Übungen gemacht hast, dann hast du es bereits gespeichert._



<p id="gdcalert79" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant77.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert80">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant77.png "image_tooltip")



#### 


#### Lösung

Mittels _Rechtsklick _in den _Assets-Bereich _und Import Assets wird der Pilz aus dem Pfad _freetileset_jungle\png\Object\Mushroom_2.jpg _importiert.


# 

<p id="gdcalert80" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant78.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert81">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant78.png "image_tooltip")


Mittels Drag & Drop ziehen wir dann den Pilz einfach an die gewünschte Position im Szenenbereich.



<p id="gdcalert81" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant79.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert82">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant79.png "image_tooltip")
 

Der Pilz bekommt nun einen 2D-Polygon-Collider: Dazu klickt man in der Spieleszene auf den Pilz und wählt im _Inspector Add Component/Physics 2D/Polygon Collider 2D._

**Score**

Nun wollen wir den Text einbauen, der anzeigt, wie oft Elli bzw. Ossi gepunktet, also den Pilz erreicht haben. Glücklicherweise bietet Unity eine Funktion an, die es erlaubt Text auf einem sogenannten User Interface anzuzeigen. 

Mittels Rechtsklick im _Hierachy_ Bereich _UI>Text  _fügen wir eine Textanzeige hinzu. 



<p id="gdcalert82" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant80.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert83">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant80.png "image_tooltip")


Hierbei wird ein Object Canvas erzeugt mit einem ChildObjekt Text. Wir benötigen insgesamt drei Texte, je einmal die Punkte für Elli und Ossi, sowie einen Text der bei Spielende erscheinen soll. Wir duplizieren also das Text-Objekt zweimal und benennen sie TextPunkteElli, TextPunkteOssi und TextGewinner.



<p id="gdcalert83" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant81.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert84">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant81.png "image_tooltip")


Danach verändern wir noch die Position der Texte für die Punktestände. 

 

<p id="gdcalert84" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant82.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert85">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant82.png "image_tooltip")




<p id="gdcalert85" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant83.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert86">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant83.png "image_tooltip")


Ihr könnt gerne die Position oder auch die Schriftgröße beliebig wählen. Beachtet jedoch, dass _Horizontal- _und _Vertical Overflow _tatsächlich auf _Overflow _gesetzt sind. Ist nämlich _Vertical Overflow _ auf _Truncate_ gesetzt, dann kann es passieren, dass euer Text ab einer gewissen Größe nicht mehr angezeigt wird. _Erklärung: Truncate bedeutet nämlich so viel wie Abschneiden oder Wegschneiden. Die Größe des Textfeldes wird ja bei bei den Eigenschaften Rect Transform unter Width und Height angegeben. Ist nun der Text größer als die angegebene Höhe und Vertical Overflow auf Truncate gesetzt,  dann wird einfach der komplette Text weggeschnitten, da er über den Rand hinaus steht. _


### Die notwendigen Änderungen für die Punkteanzeige und die Kollisionserkennung

Die benötigten Änderungen fügen wir im Script _BouncyFant.cs_ hinzu. Bei den using Klauseln kommt die Zeile _using UnityEngine.UI _hinzu. Dies ermöglicht es uns, das User Interface zu verwenden. Das Elternobjekt BouncyFant erhält noch die Variablen: _public int Punkte = 0; public Text Infotext; und public Text Gewinnertext;_.Die neu hinzukommenden Teile sind nachfolgend in Farbe dargestellt, der bisher vorhandene Quellcode ist in grau gehalten. 

**_BouncyFant.cs_**


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class BouncyFant : MonoBehaviour
{
    protected Rigidbody2D Elefantenkoerper;
    protected Animator Animation;
    public string Name;
    public float MaxGeschwindigkeit = 10;
    public float Sprungkraft = 300;
    protected int Punkte;
    public Text PunkteText;
    public Text GewinnerText;

    // Prozedur zum Bewegen des Elefanten
```


Diese Prozedur startet das Level neu.


```
    // Neuladen der Szene nach einer Wartezeit
    void NeuLaden()
    {
        SceneManager.LoadScene("sceneBouncyFant");
        Time.timeScale = 1.0f;
    }
```


Die Kollisionsbehandlung  `void OnCollisionEnter2D(Collision2D col)` prüft, ob ein Kollisionsereignis vorliegt. In `if (col.gameObject.name == "Pilz")` wird geprüft, ob der Elefant mit dem Pilz kollidiert und falls ja, dann werden die Punkte des Elefanten erhöht und ein Gewinntext ausgegeben. 

In der zweiten If-Anweisung wird geprüft, ob der Punktestand von 10 erreicht ist. Falls ja, werden die Punkte wieder zurückgesetzt.

Zum Schluss wird das Level mit einer Verzögerung von drei Sekunden neu gestartet.

**_BouncyFant.cs_**    


```
    // Beim Berühren des Pilzes die Punkte erhöhen und einen Gewinntext ausgeben.
    void OnCollisionEnter2D(Collision2D col)
    {
        // Falls das Kollisionsobjekt der Pilz ist ...    
        if (col.gameObject.name == "Pilz")
        {
            Punkte++; // Erhöhen des Punktestands um 1
            // Punktestand dauerhaft speichern,
            // damit beim Neuladen der Szene der Punktestand nicht verloren geht
            PlayerPrefs.SetInt("Punkte" + Name, Punkte);
            // Name und Punkte anzeigen
            PunkteText.text = Name + " " + Punkte.ToString(); 
            GewinnerText.text = Name + "  W I N S !"; // Gewinnermeldung 
            if (Punkte >= 10)
            {
                GewinnerText.text = "L E V E L   C O M P L E T E D"; // Geschafft
                // Rücksetzen des Punktestands für alle Elefanten auf 0 
                Punkte = 0;
                PlayerPrefs.SetInt("PunkteElli", Punkte);
                PlayerPrefs.SetInt("PunkteOssi", Punkte);
            }
            // Zerstören des Pilzes
            Destroy(col.gameObject);
            // Planen des Neuladens der Szene nach 3 Sekunden Wartezeit
            Invoke("NeuLaden", 3);
        }
    }
```


Eine kleine Wiederholung zur Vererbung beim objektorientierten Programmieren:

Da wir die Änderungen in der Elternklasse _BouncyFant _durchführen, brauchen wir dies nicht für jeden Elefanten (Elli, Ossi,...) einzeln zu tun.

Der gesamte Quellcode von **_BouncyFant.cs _**sieht nun so aus:


```
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class BouncyFant : MonoBehaviour
{
    protected Rigidbody2D Elefantenkoerper;
    protected Animator Animation;
    public string Name;
    public float MaxGeschwindigkeit = 10;
    public float Sprungkraft = 300;
    protected int Punkte;
    public Text PunkteText;
    public Text GewinnerText;

    // Prozedur zum Bewegen des Elefanten
    protected void Gehen(float h)
    {
        /* Geschwindigkeit setzen
            * Die Geschwindigkeit ergibt sich aus aus der Eingabe für die horizontale
            * Geschwindigkeit und der maximalen Höchstgeschwindigkeit des Elefanten
            */
        Elefantenkoerper.velocity = new Vector2(h * MaxGeschwindigkeit, Elefantenkoerper.velocity.y);

        /* Blickrichtung des Elefanten bestimmen.
            * Der Vektor für die Blickrichtung soll ein Vektor sein,
            * der sich aus dem Vorzeichenrückgabewert (-1 oder +1) 
            * der horizontalen Bewegungsrichtung (Mathf.Sign(h)) und 
            * dem Skalierungsfaktor auf der x-Achse ergibt.
            * Der y-Wert des Elefanten bleibt gleich, daher nehmen wir nur den 
            * Skalierungsfaktor "transform.localScale.y".       
            */
        if (h != 0)
            transform.localScale = new Vector2(Mathf.Sign(h) *
                Mathf.Abs(transform.localScale.x), transform.localScale.y);

        /* Die Geschwindigkeit wird auf den Absolutbetrag der horizontalen
            * Bewegung gesetzt. Negative Geschwindigkeit gibt es nicht.
            * z.B. wenn ich mit dem Auto im Rückwärtsgang 10km/h fahre, fahre ich 
            * 10km/h in einer Rückwärtsbewegung und nicht "-10km/h" ;)
            */
        Animation.SetFloat("Geschwindigkeit", Mathf.Abs(h));
    }

    // Feststellen, ob der Elefant am Boden ist.
    protected bool AmBoden()
    {
        // Abfragen der Grenzen der Kollisionsobjekte
        Bounds Grenze = GetComponent<Collider2D>().bounds;
        float Spielraum = Grenze.size.y * 0.1f;

        /* Berechnen einer Position die ein wenig unter der Kante des
         * Kollisionsobjekts liegt sonst kann es vorkommen, dass der 
         * Elefant nicht springen kann, wenn er ganz still steht.
         */
        Vector2 v = new Vector2(Grenze.center.x, Grenze.min.y - Spielraum);
        // Kollisionsabfrage:  mittels einer Linie  
        RaycastHit2D Kollision = Physics2D.Linecast(v, Grenze.center);

        // "true" zurückgeben, wenn das Kollisionsobjekt nicht der Elefant selbst ist.
        return (Kollision.collider.gameObject != gameObject);
    }

    // Springen
    protected void Springen(KeyCode Taste)
    {
        // Herausfinden, ob der Elefant irgendwo steht, von wo er abspringen kann
        bool springenmoeglich = AmBoden();

        /* Wenn der Pfeil nach oben gedrückt wird und Springen möglich, 
         * d.h. der Elefant hat etwas, von wo er aus wegspringen kann,
         * dann bekommt der Elefantenkörper einen Impuls (Addforce), 
         * entsprechend der von uns gewählten Sprungkraft 
         */
        if (Input.GetKey(Taste) && springenmoeglich)
            Elefantenkoerper.AddForce(Vector2.up * Sprungkraft);

        /*
         * Wenn der Elefant gerade springt, dann springen auf nicht möglich setzen.
         * Nicht = Rufzeichen(!). 
         */
        Animation.SetBool("Springen", !springenmoeglich);
    }

    // Neuladen der Szene nach einer Wartezeit
    void NeuLaden()
    {
        SceneManager.LoadScene("sceneBouncyFant");
        Time.timeScale = 1.0f;
    }

    // Beim Berühren des Pilzes die Punkte erhöhen und einen Gewinntext ausgeben.
    void OnCollisionEnter2D(Collision2D col)
    {
        // Falls das Kollisionsobjekt der Pilz ist ...    
        if (col.gameObject.name == "Pilz")
        {
            Punkte++; // Erhöhen des Punktestands um 1
            // Punktestand dauerhaft speichern,
            // damit beim Neuladen der Szene der Punktestand nicht verloren geht
            PlayerPrefs.SetInt("Punkte" + Name, Punkte);
            // Name und Punkte anzeigen
            PunkteText.text = Name + " " + Punkte.ToString(); 
            GewinnerText.text = Name + "  W I N S !"; // Gewinnermeldung 
            if (Punkte >= 10)
            {
                GewinnerText.text = "L E V E L   C O M P L E T E D"; // Geschafft
                // Rücksetzen des Punktestands für alle Elefanten auf 0 
                Punkte = 0;
                PlayerPrefs.SetInt("PunkteElli", Punkte);
                PlayerPrefs.SetInt("PunkteOssi", Punkte);
            }
            // Zerstören des Pilzes
            Destroy(col.gameObject);
            // Planen des Neuladens der Szene nach 3 Sekunden Wartezeit
            Invoke("NeuLaden", 3);
        }
    }
}
```


ToDo-Baustelle: Änderungen des Quellcodes von Elli und Ossi in die Start-Prozedur einbauen:


```
        // Laden des Punktestandes aus den Playerprefs und Anzeigen
        Punkte = PlayerPrefs.GetInt("Punkte" + Name);
        PunkteText.text = Name + " " + Punkte.ToString();
```


Dem Script von Elli weisen wir nun die entsprechenden Variablen zu indem wir auf das GameObject und dann im Scriptbereich auf dem Punkt ʘ neben der entsprechenden Variable klicken. 



<p id="gdcalert86" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant84.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert87">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant84.png "image_tooltip")


Bei Ossi tun wir das gleiche, nur, dass wir dem _Punkte Text _-> _TextPunkteOssi _zuweisen.

Zum Schluss müssen wir noch die Achsen beim Eventsystem (das beim Hinzufügen von _TextPunkteElli _und _TextPunkteOssi_ automatisch erstellt worden ist) umbenennen. Sonst erhalten wir eine Fehlermeldung, dass die Achsen Horizontal und Vertical nicht existieren, weil wir sie zu Beginn in H-AchseElli bzw. V-AchseElli umbenannt haben. Daher nennen wir die Achsen des Eventsystems ebenso H-AchseElli und V-AchseElli.

  

<p id="gdcalert87" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant85.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert88">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant85.png "image_tooltip")


 


#### Sourcecode

Download Sourcecode Teil 08: [http://comber.at/dev/BouncyFant08.zip](http://comber.at/dev/BouncyFant08.zip) 


# Teil 9 - Mehr Finetuning  


## Platform Effector

Momentan ist das Spiel schon ganz gut spielbar, doch eine Kleinigkeit trübt noch die Freude. Wenn man mit dem Elefanten gegen die Wand springt und dann gleichzeitig die Richtungstaste weiter in diese Richtung gedrückt hält, dann bleibt die Spielfigur in der Luft hängen.

Problem: Ossi hängt in der Luft, nachdem er an die Wand gesprungen ist, wenn man weiterhin nach links steuert.



<p id="gdcalert88" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant86.gif). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert89">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant86.gif "image_tooltip")


Um das Hängenbleiben zu vermeiden, bringen wir einen _Platform Effector_ zum Einsatz. Dazu klicken wir zuerst im der _Hierarchy_ auf die Spielfeldgrenzen und dann im Inspector auf _Add Component/Physics 2D/Platform Effector 2D_



<p id="gdcalert89" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant87.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert90">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant87.png "image_tooltip")
 

<p id="gdcalert90" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant88.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert91">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant88.png "image_tooltip")


Haben wir den Effector den Spielfeldgrenzen hinzugefügt, erhalten wir vorerst noch eine Warnung, dass der Effector erst funktionieren wird, wenn er von einem Collider verwendet wird. 



<p id="gdcalert91" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant89.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert92">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant89.png "image_tooltip")


Daher klicken wir bei den entsprechenden Spielfeldgrenzen, nämlich den Wänden links und rechts, einfach auf _Used by Effector _und schon sollte der Elefant, wenn wir das Spiel starten,nicht mehr in der Wand hängen bleiben, sondern nach unten rutschen.



<p id="gdcalert92" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/Bouncy-Fant90.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert93">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/Bouncy-Fant90.png "image_tooltip")



#### Sourcecode

Download Sourcecode Teil 08: [http://comber.at/dev/BouncyFant09.zip](http://comber.at/dev/BouncyFant09.zip) 

Für's erste war es das einmal mit unserem Tutorial. Schön, dass ihr dabei wart. Man könnte auch sagen, jetzt geht es erst richtig los: Neue Levels, neue Features, neue Spielfiguren, …  Lasst eurer Fantasie freien Lauf. 

Have Fun!

Glossar


<table>
  <tr>
   <td>Begriff
   </td>
   <td>Beschreibung
   </td>
   <td>Synonyme
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>



<!-- Footnotes themselves at the bottom. -->
## Notes

[^1]:
     Anm: Wenn der Listenbereicht bei euch anders aussieht dann findet ihr in Kapitel _Arbeitsbereich kennenlernen und konfigurieren _unter der Überschrift _Listenansicht im Assetsbereich _den Hinweis, wie man die Ansicht umstellt

[^2]:
     Im Englischen (und somit auch Unity) wird statt eines Kommas ein Punkt für Dezimalzahlen verwendet. Wenn man in Unity einen Beistrich als Trennzeichen für Dezimalzahlen verwendet, macht das Programm automatisch einen Punkt daraus. ACHTUNG! Beim Programmieren in C# funktioniert das allerdings nicht und man muss einen Punkt verwenden.

[^3]:
     Kostenlose freie Sprites,  Tilesets und mehr findet man z.B. auf [https://www.gameart2d.com/freebies.html](https://www.gameart2d.com/freebies.html). Die Lizenz für die kostenlosen freien Sprites und Tilesets findet ihr unter [https://www.gameart2d.com/license.html](https://www.gameart2d.com/license.html).    


<!-- GD2md-html version 1.0β13 -->
